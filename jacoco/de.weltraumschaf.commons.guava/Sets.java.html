<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Sets.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Guava</a> &gt; <a href="index.source.html" class="el_package">de.weltraumschaf.commons.guava</a> &gt; <span class="el_source">Sets.java</span></div><h1>Sets.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.weltraumschaf.commons.guava;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * Minimal set of {@code com.google.common.collect.Sets}.
 *
 * @author Kevin Bourrillion
 * @author Jared Levy
 * @author Chris Povirk
 * @since 2.0 (imported from Google Collections Library)
 * @version $Id: $Id
 */
public final class Sets {

    /**
     * Capacity ratio.
     */
    private static final int THIRD = 3;

    /**
     * Hidden for pure static factory.
     */
    private Sets() {
<span class="fc" id="L51">        super();</span>
<span class="fc" id="L52">        throw new UnsupportedOperationException(&quot;Constructor must not be called by reflection!&quot;);</span>
    }

    /**
     * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no larger than
     * expectedSize and the load factor is {@literal &gt;=} its default (0.75).
     *
     * @param expectedSize must not be negative
     * @return not negative
     */
    static int capacity(final int expectedSize) {
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if (expectedSize &lt; THIRD) {</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (!(expectedSize &gt;= 0)) {</span>
<span class="fc" id="L65">                throw new IllegalArgumentException(&quot;Parameter 'expectedSize' must not be negative!&quot;);</span>
            }

<span class="fc" id="L68">            return expectedSize + 1;</span>
        }

<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (expectedSize &lt; 1 &lt;&lt; (Integer.SIZE - 2)) {</span>
<span class="fc" id="L72">            return expectedSize + expectedSize / THIRD;</span>
        }

<span class="fc" id="L75">        return Integer.MAX_VALUE; // any large value</span>
    }

    /**
     * Creates a new hash set.
     *
     * @param &lt;E&gt; type of elements
     * @return never {@code null}, always new instance
     */
    public static &lt;E&gt; Set&lt;E&gt; newHashSet() {
<span class="nc" id="L85">        return new HashSet&lt;E&gt;();</span>
    }

    /**
     * Creates a &lt;em&gt;mutable&lt;/em&gt; {@code HashSet} instance containing the given elements in unspecified order.
     *
     * @param &lt;E&gt; type of elements
     * @param elements the elements that the set should contain
     * @return a new {@code HashSet} containing those elements (minus duplicates)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; Set&lt;E&gt; newHashSet(final E... elements) {
<span class="fc" id="L97">        final Set&lt;E&gt; set = newHashSetWithExpectedSize(elements.length);</span>
<span class="fc" id="L98">        Collections.addAll(set, elements);</span>
<span class="fc" id="L99">        return set;</span>
    }

    /**
     * Creates a {@code HashSet} instance, with a high enough &quot;initial capacity&quot; that it &lt;em&gt;should&lt;/em&gt; hold
     * {@code expectedSize} elements without growth.
     *
     * &lt;p&gt;
     * This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.6. It also can't be
     * guaranteed that the method isn't inadvertently &lt;i&gt;oversizing&lt;/i&gt; the returned set.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; type of elements
     * @param expectedSize the number of elements you expect to add to the returned set
     * @return a new, empty {@code HashSet} with enough capacity to hold {@code
     *         expectedSize} elements without resizing //CHECKSTYLE:OFF
     * @throws java.lang.IllegalArgumentException if {@code expectedSize} is negative //CHECKSTYLE:ON
     */
    public static &lt;E&gt; Set&lt;E&gt; newHashSetWithExpectedSize(final int expectedSize) {
<span class="fc" id="L118">        return new HashSet&lt;E&gt;(capacity(expectedSize));</span>
    }

    /**
     * Creates a new tree set.
     *
     * @param &lt;E&gt; type of elements
     * @return never {@code null}, always new instance
     */
    public static &lt;E&gt; SortedSet&lt;E&gt; newTreeSet() {
<span class="nc" id="L128">        return new TreeSet&lt;E&gt;();</span>
    }

    /**
     * Creates an empty {@code Set} that uses identity to determine equality. It compares object references, instead of
     * calling {@code equals}, to determine whether a provided object matches an element in the set. For example,
     * {@code contains} returns {@code false} when passed an object that equals a set member, but isn't the same
     * instance. This behavior is similar to the way {@code IdentityHashMap} handles key lookups.
     *
     * @since 8.0
     * @param &lt;E&gt; a E object.
     * @return a {@link java.util.Set} object.
     */
    public static &lt;E&gt; Set&lt;E&gt; newIdentityHashSet() {
<span class="nc" id="L142">        return Sets.newSetFromMap(Maps.&lt;E, Boolean&gt;newIdentityHashMap());</span>
    }

    /**
     * Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and
     * performance characteristics as the backing map. In essence, this factory method provides a {@link java.util.Set}
     * implementation corresponding to any {@link java.util.Map} implementation. There is no need to use this method on a
     * {@link java.util.Map} implementation that already has a corresponding {@link java.util.Set} implementation (such as
     * {@link java.util.HashMap} or {@link java.util.TreeMap}).
     *
     * &lt;p&gt;
     * Each method invocation on the set returned by this method results in exactly one method invocation on the backing
     * map or its {@code keySet} view, with one exception. The {@code addAll} method is implemented as a sequence of
     * {@code put} invocations on the backing map.
     *
     * &lt;p&gt;
     * The specified map must be empty at the time this method is invoked, and should not be accessed directly after
     * this method returns. These conditions are ensured if the map is created empty, passed directly to this method,
     * and no reference to the map is retained, as illustrated in the following code fragment:
     * &lt;pre&gt;  {@code
     *
     *   Set&lt;Object&gt; identityHashSet = Sets.newSetFromMap(
     *       new IdentityHashMap&lt;Object, Boolean&gt;());}&lt;/pre&gt;
     *
     * This method has the same behavior as the JDK 6 method {@code Collections.newSetFromMap()}. The returned set is
     * serializable if the backing map is.
     *
     * @param map the backing map
     * @return the set backed by the map
     * @throws java.lang.IllegalArgumentException if {@code map} is not empty
     * @param &lt;E&gt; a E object.
     */
    public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
<span class="nc" id="L175">        return new SetFromMap&lt;E&gt;(map);</span>
    }

    /**
     * Ensures the truth of an expression involving one or more parameters to the calling method.
     *
     * @param expression a boolean expression
     * @param errorMessage the exception message to use if the check fails; will be converted to a string using
     * {@link java.lang.String#valueOf(Object)}
     * @throws java.lang.IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(
            boolean expression, Object errorMessage) {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (!expression) {</span>
<span class="nc" id="L189">            throw new IllegalArgumentException(String.valueOf(errorMessage));</span>
        }
<span class="nc" id="L191">    }</span>

    private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Serializable {

        private final Map&lt;E, Boolean&gt; m; // The backing map
        private transient Set&lt;E&gt; s; // Its keySet

<span class="nc" id="L198">        SetFromMap(Map&lt;E, Boolean&gt; map) {</span>
<span class="nc" id="L199">            checkArgument(map.isEmpty(), &quot;Map is non-empty&quot;);</span>
<span class="nc" id="L200">            m = map;</span>
<span class="nc" id="L201">            s = map.keySet();</span>
<span class="nc" id="L202">        }</span>

        @Override
        public void clear() {
<span class="nc" id="L206">            m.clear();</span>
<span class="nc" id="L207">        }</span>

        @Override
        public int size() {
<span class="nc" id="L211">            return m.size();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="nc" id="L216">            return m.isEmpty();</span>
        }

        @Override
        public boolean contains(Object o) {
<span class="nc" id="L221">            return m.containsKey(o);</span>
        }

        @Override
        public boolean remove(Object o) {
<span class="nc bnc" id="L226" title="All 2 branches missed.">            return m.remove(o) != null;</span>
        }

        @Override
        public boolean add(E e) {
<span class="nc bnc" id="L231" title="All 2 branches missed.">            return m.put(e, Boolean.TRUE) == null;</span>
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
<span class="nc" id="L236">            return s.iterator();</span>
        }

        @Override
        public Object[] toArray() {
<span class="nc" id="L241">            return s.toArray();</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L246">            return s.toArray(a);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L251">            return s.toString();</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L256">            return s.hashCode();</span>
        }

        @Override
        public boolean equals(Object object) {
<span class="nc bnc" id="L261" title="All 4 branches missed.">            return this == object || this.s.equals(object);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
<span class="nc" id="L266">            return s.containsAll(c);</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L271">            return s.removeAll(c);</span>
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L276">            return s.retainAll(c);</span>
        }

        // addAll is the only inherited implementation
        private static final long serialVersionUID = 0;

        private void readObject(ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
<span class="nc" id="L284">            stream.defaultReadObject();</span>
<span class="nc" id="L285">            s = m.keySet();</span>
<span class="nc" id="L286">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>