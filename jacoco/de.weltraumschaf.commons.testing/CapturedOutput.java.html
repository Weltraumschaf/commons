<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CapturedOutput.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Testing</a> &gt; <a href="index.source.html" class="el_package">de.weltraumschaf.commons.testing</a> &gt; <span class="el_source">CapturedOutput.java</span></div><h1>CapturedOutput.java</h1><pre class="source lang-java linenums">/*
 *  LICENSE
 *
 * &quot;THE BEER-WARE LICENSE&quot; (Revision 43):
 * &quot;Sven Strittmatter&quot; &amp;lt;weltraumschaf@googlemail.com&amp;gt; wrote this file.
 * As long as you retain this notice you can do whatever you want with
 * this stuff. If we meet some day, and you think this stuff is worth it,
 * you can buy me a non alcohol-free beer in return.
 *
 * Copyright (C) 2012 &quot;Sven Strittmatter&quot; &amp;lt;weltraumschaf@googlemail.com&amp;gt;
 */
package de.weltraumschaf.commons.testing;

import java.io.IOError;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.containsString;
import org.hamcrest.Matcher;
import static org.hamcrest.MatcherAssert.assertThat;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

/**
 * This rule captures all output written to {@link java.lang.System#out} and {@link java.lang.System#err}.
 *
 * &lt;p&gt;
 * This rule redirects the constant print streams for out/err to an {@link de.weltraumschaf.commons.testing.CapturingPrintStream} before each test and
 * backups the origin streams after each test.
 * &lt;/p&gt;
 *
 * &lt;pre&gt;{@code
 * public class OutputTest {
 *
 *     &amp;#064;Rule
 *     public final CapturedOutput output = new CapturedOutput();
 *
 *     &amp;#064;Test
 *     public void captureOut() {
 *         output.expectOut(&quot;foobar&quot;);
 *         output.expectOut(not(&quot;snafu&quot;));
 *
 *         System.out.print(&quot;foobar&quot;);
 *     }
 *
 *     &amp;#064;Test
 *     public void captureErr() {
 *         output.expectErr(&quot;foobar&quot;);
 *         output.expectErr(not(&quot;snafu&quot;));
 *
 *         System.err.print(&quot;foobar&quot;);
 *     }
 *
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 * @author Sven Strittmatter &amp;lt;weltraumschaf@googlemail.com&amp;gt;
 * @version $Id: $Id
 */
public final class CapturedOutput implements TestRule {

    /**
     * Build the matchers for STDOUT expectations.
     */
<span class="fc" id="L70">    private final CapturedOutputMatcherBuilder outMatcherBuilder = new CapturedOutputMatcherBuilder();</span>
    /**
     * Build the matchers for STDERR expectations.
     */
<span class="fc" id="L74">    private final CapturedOutputMatcherBuilder errMatcherBuilder = new CapturedOutputMatcherBuilder();</span>
    /**
     * Captures the data written to STDOUT.
     */
    private final CapturingPrintStream out;
    /**
     * Captures the data written to STDERR.
     */
    private final CapturingPrintStream err;
    /**
     * Holds the original STDOUT from before test method.
     */
    private PrintStream outBackup;
    /**
     * Holds the original STDERR from before test method.
     */
    private PrintStream errBackup;

    /**
     * Creates a capturing rule with platform encoding.
     */
    public CapturedOutput() {
<span class="fc" id="L96">        this(Charset.defaultCharset().name());</span>
<span class="fc" id="L97">    }</span>

    /**
     * Dedicated constructor.
     *
     * @param encoding must not be {@code null} or empty
     */
<span class="fc" id="L104">    public CapturedOutput(final String encoding) {</span>
        try {
<span class="fc" id="L106">            out = new CapturingPrintStream(encoding);</span>
<span class="fc" id="L107">            err = new CapturingPrintStream(encoding);</span>
<span class="nc" id="L108">        } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L109">            throw new IOError(ex);</span>
<span class="fc" id="L110">        }</span>
<span class="fc" id="L111">    }</span>

    /**
     * Adds to the list of requirements for any output printed to STDOUT that it should &lt;em&gt;contain&lt;/em&gt; string
     * {@code substring}.
     *
     * @param substring must not be {@code null}
     */
    public void expectOut(final String substring) {
<span class="fc" id="L120">        expectOut(containsString(notNull(substring, &quot;substring&quot;)));</span>
<span class="fc" id="L121">    }</span>

    /**
     * Adds to the list of requirements for any output printed to STDOUT.
     *
     * @param matcher must not be {@code null}
     */
    public void expectOut(final Matcher&lt;String&gt; matcher) {
<span class="fc" id="L129">        outMatcherBuilder.add(notNull(matcher, &quot;matcher&quot;));</span>
<span class="fc" id="L130">    }</span>

    /**
     * Adds to the list of requirements for any output printed to STDERR that it should &lt;em&gt;contain&lt;/em&gt; string
     * {@code substring}.
     *
     * @param substring must not be {@code null}
     */
    public void expectErr(final String substring) {
<span class="fc" id="L139">        expectErr(containsString(notNull(substring, &quot;substring&quot;)));</span>
<span class="fc" id="L140">    }</span>

    /**
     * Adds to the list of requirements for any output printed to STDERR.
     *
     * @param matcher must not be {@code null}
     */
    public void expectErr(final Matcher&lt;String&gt; matcher) {
<span class="fc" id="L148">        errMatcherBuilder.add(notNull(matcher, &quot;matcher&quot;));</span>
<span class="fc" id="L149">    }</span>

    /** {@inheritDoc} */
    @Override
    public Statement apply(final Statement base, final Description description) {
<span class="fc" id="L154">        return new Statement() {</span>
            @Override
            // CHECKSTYLE:OFF
            // Throwable required by API.
            public void evaluate() throws Throwable {
            // CHECKSTYLE:ON
<span class="fc" id="L160">                redirectOutputStreams();</span>

                try {
<span class="fc" id="L163">                    base.evaluate();</span>
<span class="fc" id="L164">                    assertCapturedOut();</span>
<span class="fc" id="L165">                    assertCapturedErr();</span>
                } finally {
<span class="pc" id="L167">                    restoreOutputStreams();</span>
<span class="fc" id="L168">                }</span>
<span class="fc" id="L169">            }</span>
        };
    }

    /**
     * Set and backup STDERR/STDOUT print streams.
     */
    private void redirectOutputStreams() {
<span class="fc" id="L177">        outBackup = System.out;</span>
<span class="fc" id="L178">        System.setOut(out.reset());</span>
<span class="fc" id="L179">        errBackup = System.err;</span>
<span class="fc" id="L180">        System.setErr(err.reset());</span>
<span class="fc" id="L181">    }</span>

    /**
     * Applies matchers on captured error output if there are any matchers.
     *
     * @throws UnsupportedEncodingException if the platform encoding is not supported
     */
    private void assertCapturedErr() throws UnsupportedEncodingException {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (errMatcherBuilder.expectsSomething()) {</span>
<span class="fc" id="L190">            assertThat(err.getCapturedOutput(), errMatcherBuilder.build());</span>
        }
<span class="fc" id="L192">    }</span>

    /**
     * Applies matchers on captured standard output if there are any matchers.
     *
     * @throws UnsupportedEncodingException if the platform encoding is not supported
     */
    private void assertCapturedOut() throws UnsupportedEncodingException {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (outMatcherBuilder.expectsSomething()) {</span>
<span class="fc" id="L201">            assertThat(out.getCapturedOutput(), outMatcherBuilder.build());</span>
        }
<span class="fc" id="L203">    }</span>

    /**
     * Restore STDERR/STDOUT print streams.
     */
    private void restoreOutputStreams() {
<span class="fc" id="L209">        System.setOut(outBackup);</span>
<span class="fc" id="L210">        System.setErr(errBackup);</span>
<span class="fc" id="L211">    }</span>

    /**
     * Validates that given subject is not {@code null}.
     *
     * &lt;p&gt;
     * Will throw {@link NullPointerException} if subject is {@code null}.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; type of subject
     * @param subject tested subject
     * @param description name of tested subject for exception message
     * @return the subject, if not {@code null}
     */
    private static &lt;T&gt; T notNull(final T subject, final String description) {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (null == subject) {</span>
<span class="nc" id="L227">            throw new NullPointerException(String.format(&quot;Parameter '%s' must not be null!&quot;, description));</span>
        }

<span class="fc" id="L230">        return subject;</span>
    }

    /**
     * Builds string matchers.
     */
<span class="fc" id="L236">    private static final class CapturedOutputMatcherBuilder {</span>

        /**
         * Hold all matchers.
         */
<span class="fc" id="L241">        private final List&lt;Matcher&lt;String&gt;&gt; matchers = new ArrayList&lt;Matcher&lt;String&gt;&gt;();</span>

        /**
         * Adds a matcher.
         *
         * @param matcher must not be {@code null}
         */
        void add(final Matcher&lt;String&gt; matcher) {
<span class="fc" id="L249">            matchers.add(matcher);</span>
<span class="fc" id="L250">        }</span>

        /**
         * Whether the builder has any matcher.
         *
         * @return {@code true} if there are matchers, else {@code false}
         */
        boolean expectsSomething() {
<span class="fc bfc" id="L258" title="All 2 branches covered.">            return !matchers.isEmpty();</span>
        }

        /**
         * Returns the combined matcher.
         *
         * @return never {@code null}
         */
        Matcher&lt;String&gt; build() {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            if (matchers.size() == 1) {</span>
<span class="nc" id="L268">                return matchers.get(0);</span>
            }

<span class="fc" id="L271">            return allOf(castedMatchers());</span>
        }

        /**
         * Casts list to matchers of super type string.
         *
         * @return new instance, not {@code null}
         */
        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot; })
        private List&lt;Matcher&lt;? super String&gt;&gt; castedMatchers() {
<span class="fc" id="L281">            return new ArrayList&lt;Matcher&lt;? super String&gt;&gt;((List) matchers);</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>